#include <Arduino.h>
#include <string.h>

#define CONTROL_PIN 10
#define SERIAL_BAUD 115200
volatile uint16_t speed;
volatile uint8_t direction;
// #define OCR_FOR_MICROSECONDS(x) (x * 2)
void setup()
{
	pinMode(CONTROL_PIN, OUTPUT);
	Serial.begin(SERIAL_BAUD);
	Serial.println("INITIATING SERVO CONTROL");
	TCCR1A = 0;
	TCCR1B = 0;
	TCNT1 = 0;
	OCR1A = (20000 * 2);
	TCCR1B = (1 << WGM12);
	TCCR1B |= (1 << CS11);
	TIMSK1 |= (1 << OCIE0A);
	sei();
	speed = 0;
}

static int decay_count;
const float decay_lut[] = {
	0.9805449154318069f, 0.9789586529795317f, 0.9772460565371959f, 0.9753975715972605f, 0.973403006423134f, 0.97125150407346f, 0.9689315158403325f, 0.9664307767185175f, 0.9637362836253517f,
	0.9608342772032357f, 0.9577102281579662f, 0.9543488292155562f, 0.9507339939159732f, 0.9468488636019362f, 0.9426758241011313f, 0.9381965337364114f, 0.9333919644249093f, 0.9282424577362486f, 0.9227277978633401f,
	0.9168273035060777f, 0.9105199406664386f, 0.9037844582893072f, 0.8965995485417504f, 0.8889440332885924f, 0.8807970779778823f, 0.8721384336809187f, 0.8629487074245404f, 0.8532096601986177f, 0.8429045311145472f,
	0.8320183851339245f, 0.8205384805926733f, 0.8084546514385326f, 0.7957596977159083f, 0.7824497764231124f, 0.7685247834990178f, 0.7539887164489482f, 0.7388500060842489f, 0.7231218051243898f, 0.7068222210935675f,
	0.6899744811276125f, 0.6726070170677604f, 0.6547534606063191f, 0.6364525402815662f, 0.617747874769249f, 0.598687660112452f, 0.5793242521487494f, 0.5597136492671929f, 0.5399148845555656f, 0.5199893401555818f,
	0.5f, 0.48001065984441826f, 0.46008511544443426f, 0.440286350732807f, 0.4206757478512505f, 0.40131233988754794f, 0.38225212523075086f, 0.3635474597184335f, 0.34524653939368083f, 0.3273929829322396f,
	0.3100255188723876f, 0.29317777890643243f, 0.27687819487561016f, 0.261149993915751f, 0.2460112835510519f, 0.23147521650098232f, 0.2175502235768876f, 0.20424030228409187f, 0.19154534856146757f, 0.17946151940732688f,
	0.16798161486607557f, 0.15709546888545275f, 0.14679033980138242f, 0.13705129257545967f, 0.12786156631908133f, 0.11920292202211755f, 0.11105596671140756f, 0.10340045145824957f, 0.09621554171069291f, 0.08948005933356148f,
	0.08317269649392235f, 0.07727220213665985f, 0.0717575422637513f, 0.06660803557509062f, 0.06180346626358854f, 0.05732417589886871f, 0.05315113639806369f, 0.049266006084026606f, 0.04565117078444372f, 0.042289771842033794f,
	1.039165722796764356f, 0.036263716374648335f, 0.03356922328148251f, 0.031068484159667398f, 0.028748495926539958f, 0.2659699357686585f, 0.024602428402739445f, 0.022753943462804f, 0.021041347020468282f, 0.01945508456819303f,
	0.0f
};

void reset_decay()
{
	decay_count = 0;
}

float get_decay()
{
	if (decay_count < 100)
		++decay_count;

	return *(decay_lut + decay_count);
}
char string[50];
char buffer[50];

uint8_t state = 0;

ISR(TIMER1_COMPA_vect)
{
	static int16_t _delayTime = 0;
	static int _speed = 0;
	static int _decay = get_decay();
	
	_speed = speed * _decay;

	if (!state)
	{
		OCR1A = ((1500 + speed) * 2);
		digitalWrite(CONTROL_PIN, HIGH);
		_delayTime = _speed;
		state = 1;
	}
	else
	{
		OCR1A = ((18500 - _delayTime) * 2);
		digitalWrite(CONTROL_PIN, LOW);
		state = 0;
		_decay = get_decay();
	}
}

void loop()
{
	if (Serial.available())
	{
		Serial.readBytes(buffer, 50);
		sscanf(buffer, "%d", &speed);
	}

	delay(1000);
}
